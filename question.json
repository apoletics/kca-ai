[
    {
        "question": "Which Kyverno CRD defines policy behaviors and rules?",
        "options": {
            "A": "PolicyReport",
            "B": "ClusterPolicy",
            "C": "AdmissionReview",
            "D": "ValidationPolicy"
        },
        "answer": "B"
    },
    {
        "question": "What is the primary purpose of the Common Expression Language (CEL) in Kyverno policies?",
        "options": {
            "A": "Define resource YAML structure",
            "B": "Write conditional logic for policy rules",
            "C": "Generate Kubernetes manifests",
            "D": "Configure RBAC permissions"
        },
        "answer": "B"
    },
    {
        "question": "Which command installs Kyverno in a highly available configuration with 3 replicas?",
        "options": {
            "A": "helm install kyverno kyverno/kyverno --set replicaCount=3",
            "B": "kubectl apply -f https://kyverno.io/install/release-1.4/kyverno.yaml",
            "C": "kyverno init --ha",
            "D": "helm upgrade kyverno --replicas 3"
        },
        "answer": "A"
    },
    {
        "question": "Which flag in kyverno apply specifies a resource file to evaluate against a policy?",
        "options": {
            "A": "--policy",
            "B": "--resource",
            "C": "--cluster",
            "D": "--output"
        },
        "answer": "B"
    },
    {
        "question": "What is the default validationFailureAction for Kyverno policies?",
        "options": {
            "A": "Enforce",
            "B": "Audit",
            "C": "Warn",
            "D": "Ignore"
        },
        "answer": "B"
    },
    {
        "question": "Which policy type modifies resource specifications during admission?",
        "options": {
            "A": "Validation",
            "B": "Mutation",
            "C": "Generate",
            "D": "Audit"
        },
        "answer": "B"
    },
    {
        "question": "How do you exclude a namespace from a policy using the exclude block?",
        "options": {
            "A": "exclude: { namespaces: [\"prod\"] }",
            "B": "exclude: { resources: { namespaces: [\"prod\"] } }",
            "C": "exclude: { any: [{ resources: { namespaces: [\"prod\"] } }] }",
            "D": "exclude: { all: [{ resources: { namespaces: [\"prod\"] } }] }"
        },
        "answer": "C"
    },
    {
        "question": "Which CLI command generates a test file for validating a policy against a resource?",
        "options": {
            "A": "kyverno test",
            "B": "kyverno generate test",
            "C": "kyverno create test",
            "D": "kyverno validate"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct CEL expression to check if a pod has a label 'app=web'?",
        "options": {
            "A": "request.object.metadata.labels.app == 'web'",
            "B": "request.object.labels.app == 'web'",
            "C": "object.metadata.labels.app == 'web'",
            "D": "request.labels.app == 'web'"
        },
        "answer": "A"
    },
    {
        "question": "Which controller handles background scans for generate and mutate-existing policies?",
        "options": {
            "A": "Webhook server",
            "B": "Background controller",
            "C": "Report controller",
            "D": "Certificate renewer"
        },
        "answer": "B"
    },
    {
        "question": "How do you reference a configmap in a policy's context?",
        "options": {
            "A": "context: [{ configMap: { name: 'my-config' } }]",
            "B": "variables: [{ configMap: { name: 'my-config' } }]",
            "C": "dataSources: [{ configMap: { name: 'my-config' } }]",
            "D": "sources: [{ configMap: { name: 'my-config' } }]"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno metric tracks the latency of rule execution?",
        "options": {
            "A": "policy_rule_execution_latency_seconds",
            "B": "kyverno_policy_evaluations_total",
            "C": "policy_cache_size_bytes",
            "D": "mutation_requests_total"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the 'synchronize' field in generate rules?",
        "options": {
            "A": "Ensure generated resources match the policy",
            "B": "Trigger periodic background scans",
            "C": "Enable RBAC for generated resources",
            "D": "Define the namespace for generated resources"
        },
        "answer": "A"
    },
    {
        "question": "Which field in a PolicyException CRD specifies policies to exclude?",
        "options": {
            "A": "policies",
            "B": "targets",
            "C": "exceptions",
            "D": "resources"
        },
        "answer": "A"
    },
    {
        "question": "Which controller uses leader election for high availability?",
        "options": {
            "A": "Webhook server",
            "B": "Generate controller",
            "C": "Background controller",
            "D": "Report controller"
        },
        "answer": "B"
    },
    {
        "question": "What is the correct way to write a JSON Patch RFC 6902 mutation rule?",
        "options": {
            "A": "patches: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "B": "patchesJson6902: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "C": "patchesStrategicMerge: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "D": "mutation: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]"
        },
        "answer": "B"
    },
    {
        "question": "Which command applies a policy to all resources in the current cluster?",
        "options": {
            "A": "kyverno apply --cluster",
            "B": "kyverno apply --all",
            "C": "kyverno apply --namespace all",
            "D": "kyverno apply --resource all"
        },
        "answer": "A"
    },
    {
        "question": "What is the default policy enforcement mode for validation rules?",
        "options": {
            "A": "Enforce",
            "B": "Audit",
            "C": "Warn",
            "D": "DryRun"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL function checks if a string starts with 'prod-'?",
        "options": {
            "A": "startsWith(request.object.metadata.name, 'prod-')",
            "B": "request.object.metadata.name.startsWith('prod-')",
            "C": "string.startsWith(request.object.metadata.name, 'prod-')",
            "D": "request.object.name.startsWith('prod-')"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure Kyverno to use an external API call in a policy?",
        "options": {
            "A": "context: [{ apiCall: { url: 'http://api.example.com' } }]",
            "B": "variables: [{ apiCall: { url: 'http://api.example.com' } }]",
            "C": "dataSources: [{ apiCall: { url: 'http://api.example.com' } }]",
            "D": "sources: [{ apiCall: { url: 'http://api.example.com' } }]"
        },
        "answer": "A"
    },
    {
        "question": "Which controller manages certificate renewal for webhooks?",
        "options": {
            "A": "Certificate renewer",
            "B": "Webhook server",
            "C": "Policy controller",
            "D": "Report controller"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the 'failurePolicy' field in a policy?",
        "options": {
            "A": "Define how to handle policy evaluation errors",
            "B": "Set the enforcement mode for validation rules",
            "C": "Exclude resources from policy evaluation",
            "D": "Configure RBAC permissions for the policy"
        },
        "answer": "A"
    },
    {
        "question": "Which command generates a policy report for all resources in a namespace?",
        "options": {
            "A": "kyverno report --namespace default",
            "B": "kyverno generate report --namespace default",
            "C": "kubectl get policyreports -n default",
            "D": "kubectl apply -f report.yaml"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to reference a variable from a configmap in a policy rule?",
        "options": {
            "A": "{{ myConfig.data.key }}",
            "B": "{{ context.myConfig.data.key }}",
            "C": "{{ variables.myConfig.data.key }}",
            "D": "{{ dataSources.myConfig.data.key }}"
        },
        "answer": "B"
    },
    {
        "question": "Which policy type creates new Kubernetes resources based on a template?",
        "options": {
            "A": "Validation",
            "B": "Mutation",
            "C": "Generate",
            "D": "Audit"
        },
        "answer": "C"
    },
    {
        "question": "How do you specify multiple match conditions in a policy rule?",
        "options": {
            "A": "match: { any: [{ resources: { kinds: ['Pod'] } }, { namespaces: ['prod'] }] }",
            "B": "match: { all: [{ resources: { kinds: ['Pod'] } }, { namespaces: ['prod'] }] }",
            "C": "match: { resources: { kinds: ['Pod'], namespaces: ['prod'] } }",
            "D": "match: { any: { resources: { kinds: ['Pod'] } }, all: { namespaces: ['prod'] } }"
        },
        "answer": "B"
    },
    {
        "question": "Which Kyverno component dynamically configures admission webhooks?",
        "options": {
            "A": "Webhook controller",
            "B": "Background controller",
            "C": "Report controller",
            "D": "Policy controller"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the 'background' field in a policy?",
        "options": {
            "A": "Apply policies to existing resources",
            "B": "Enable periodic background scans",
            "C": "Configure RBAC permissions",
            "D": "Exclude resources from policy evaluation"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command checks policy compliance without modifying resources?",
        "options": {
            "A": "kyverno validate",
            "B": "kyverno test",
            "C": "kyverno apply --dry-run",
            "D": "kyverno generate"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to write a strategic merge patch mutation rule?",
        "options": {
            "A": "patches: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "B": "patchesJson6902: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "C": "patchesStrategicMerge: { spec: { containers: [{ resources: { limits: { cpu: '100m' } } }] } }",
            "D": "mutation: { spec: { containers: [{ resources: { limits: { cpu: '100m' } } }] } }"
        },
        "answer": "C"
    },
    {
        "question": "Which Kyverno CRD aggregates policy compliance results across the cluster?",
        "options": {
            "A": "ClusterPolicyReport",
            "B": "PolicyException",
            "C": "ClusterPolicy",
            "D": "ValidationFailure"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `synchronize` field in generate rules?",
        "options": {
            "A": "Ensure generated resources match the policy",
            "B": "Trigger periodic background scans",
            "C": "Enable RBAC for generated resources",
            "D": "Define the namespace for generated resources"
        },
        "answer": "A"
    },
    {
        "question": "Which command generates a policy report for all resources in a namespace?",
        "options": {
            "A": "kyverno report --namespace default",
            "B": "kubectl get policyreports -n default",
            "C": "kyverno generate report --namespace default",
            "D": "kubectl apply -f report.yaml"
        },
        "answer": "B"
    },
    {
        "question": "What is the correct CEL expression to check if a pod's CPU limit exceeds 500m?",
        "options": {
            "A": "request.object.spec.containers[0].resources.limits.cpu > '500m'",
            "B": "object.spec.containers[0].resources.limits.cpu > 500m",
            "C": "request.object.limits.cpu > '500m'",
            "D": "object.resources.limits.cpu > 500m"
        },
        "answer": "A"
    },
    {
        "question": "Which field in a PolicyException CRD specifies policies to exclude?",
        "options": {
            "A": "policies",
            "B": "targets",
            "C": "exceptions",
            "D": "resources"
        },
        "answer": "A"
    },
    {
        "question": "How do you configure Kyverno to use an external API call in a policy?",
        "options": {
            "A": "context: [{ apiCall: { url: 'http://api.example.com' } }]",
            "B": "variables: [{ apiCall: { url: 'http://api.example.com' } }]",
            "C": "dataSources: [{ apiCall: { url: 'http://api.example.com' } }]",
            "D": "sources: [{ apiCall: { url: 'http://api.example.com' } }]"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno metric tracks the total number of policy evaluations?",
        "options": {
            "A": "kyverno_policy_evaluations_total",
            "B": "policy_rule_execution_latency_seconds",
            "C": "policy_cache_size_bytes",
            "D": "mutation_requests_total"
        },
        "answer": "A"
    },
    {
        "question": "What is the default enforcement mode for validation rules?",
        "options": {
            "A": "Enforce",
            "B": "Audit",
            "C": "Warn",
            "D": "DryRun"
        },
        "answer": "B"
    },
    {
        "question": "Which controller handles background scans for generate and mutate-existing policies?",
        "options": {
            "A": "Webhook server",
            "B": "Background controller",
            "C": "Report controller",
            "D": "Certificate renewer"
        },
        "answer": "B"
    },
    {
        "question": "How do you exclude a namespace from a policy using the exclude block?",
        "options": {
            "A": "exclude: { namespaces: [\"prod\"] }",
            "B": "exclude: { resources: { namespaces: [\"prod\"] } }",
            "C": "exclude: { any: [{ resources: { namespaces: [\"prod\"] } }] }",
            "D": "exclude: { all: [{ resources: { namespaces: [\"prod\"] } }] }"
        },
        "answer": "C"
    },
    {
        "question": "Which CLI command checks policy compliance without modifying resources?",
        "options": {
            "A": "kyverno validate",
            "B": "kyverno test",
            "C": "kyverno apply --dry-run",
            "D": "kyverno generate"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to reference a variable from a configmap in a policy rule?",
        "options": {
            "A": "{{ myConfig.data.key }}",
            "B": "{{ context.myConfig.data.key }}",
            "C": "{{ variables.myConfig.data.key }}",
            "D": "{{ dataSources.myConfig.data.key }}"
        },
        "answer": "B"
    },
    {
        "question": "Which policy type creates new Kubernetes resources based on a template?",
        "options": {
            "A": "Validation",
            "B": "Mutation",
            "C": "Generate",
            "D": "Audit"
        },
        "answer": "C"
    },
    {
        "question": "How do you specify multiple match conditions in a policy rule?",
        "options": {
            "A": "match: { any: [{ resources: { kinds: ['Pod'] } }, { namespaces: ['prod'] }] }",
            "B": "match: { all: [{ resources: { kinds: ['Pod'] } }, { namespaces: ['prod'] }] }",
            "C": "match: { resources: { kinds: ['Pod'], namespaces: ['prod'] } }",
            "D": "match: { any: { resources: { kinds: ['Pod'] } }, all: { namespaces: ['prod'] } }"
        },
        "answer": "B"
    },
    {
        "question": "Which Kyverno component dynamically configures admission webhooks?",
        "options": {
            "A": "Webhook controller",
            "B": "Background controller",
            "C": "Report controller",
            "D": "Policy controller"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the 'background' field in a policy?",
        "options": {
            "A": "Apply policies to existing resources",
            "B": "Enable periodic background scans",
            "C": "Configure RBAC permissions",
            "D": "Exclude resources from policy evaluation"
        },
        "answer": "A"
    },
    {
        "question": "Which command installs Kyverno in a highly available configuration with 3 replicas?",
        "options": {
            "A": "helm install kyverno kyverno/kyverno --set replicaCount=3",
            "B": "kubectl apply -f https://kyverno.io/install/release-1.4/kyverno.yaml",
            "C": "kyverno init --ha",
            "D": "helm upgrade kyverno --replicas 3"
        },
        "answer": "A"
    },
    {
        "question": "What is the correct way to write a JSON Patch RFC 6902 mutation rule?",
        "options": {
            "A": "patches: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "B": "patchesJson6902: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "C": "patchesStrategicMerge: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "D": "mutation: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]"
        },
        "answer": "B"
    },
    {
        "question": "Which flag in kyverno apply specifies a resource file to evaluate against a policy?",
        "options": {
            "A": "--policy",
            "B": "--resource",
            "C": "--cluster",
            "D": "--output"
        },
        "answer": "B"
    },
    {
        "question": "What is the primary purpose of the Common Expression Language (CEL) in Kyverno policies?",
        "options": {
            "A": "Define resource YAML structure",
            "B": "Write conditional logic for policy rules",
            "C": "Generate Kubernetes manifests",
            "D": "Configure RBAC permissions"
        },
        "answer": "B"
    },
    {
        "question": "Which controller uses leader election for high availability?",
        "options": {
            "A": "Webhook server",
            "B": "Generate controller",
            "C": "Background controller",
            "D": "Report controller"
        },
        "answer": "B"
    },
    {
        "question": "What is the correct CEL expression to check if a pod has a label 'app=web'?",
        "options": {
            "A": "request.object.metadata.labels.app == 'web'",
            "B": "request.object.labels.app == 'web'",
            "C": "object.metadata.labels.app == 'web'",
            "D": "request.labels.app == 'web'"
        },
        "answer": "A"
    },
    {
        "question": "Which command applies a policy to all resources in the current cluster?",
        "options": {
            "A": "kyverno apply --cluster",
            "B": "kyverno apply --all",
            "C": "kyverno apply --namespace all",
            "D": "kyverno apply --resource all"
        },
        "answer": "A"
    },
    {
        "question": "How do you reference a configmap in a policy's context?",
        "options": {
            "A": "context: [{ configMap: { name: 'my-config' } }]",
            "B": "variables: [{ configMap: { name: 'my-config' } }]",
            "C": "dataSources: [{ configMap: { name: 'my-config' } }]",
            "D": "sources: [{ configMap: { name: 'my-config' } }]"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the 'failurePolicy' field in a policy?",
        "options": {
            "A": "Define how to handle policy evaluation errors",
            "B": "Set the enforcement mode for validation rules",
            "C": "Exclude resources from policy evaluation",
            "D": "Configure RBAC permissions for the policy"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command generates a test file for validating a policy against a resource?",
        "options": {
            "A": "kyverno test",
            "B": "kyverno generate test",
            "C": "kyverno create test",
            "D": "kyverno validate"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to write a strategic merge patch mutation rule?",
        "options": {
            "A": "patches: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "B": "patchesJson6902: [{ op: 'add', path: '/spec/containers/0/resources', value: { limits: { cpu: '100m' } } }]",
            "C": "patchesStrategicMerge: { spec: { containers: [{ resources: { limits: { cpu: '100m' } } }] } }",
            "D": "mutation: { spec: { containers: [{ resources: { limits: { cpu: '100m' } } }] } }"
        },
        "answer": "C"
    },
    {
        "question": "Which CEL function checks if a string starts with 'prod-'?",
        "options": {
            "A": "startsWith(request.object.metadata.name, 'prod-')",
            "B": "request.object.metadata.name.startsWith('prod-')",
            "C": "string.startsWith(request.object.metadata.name, 'prod-')",
            "D": "request.object.name.startsWith('prod-')"
        },
        "answer": "B"
    },
    {
        "question": "Which controller manages certificate renewal for webhooks?",
        "options": {
            "A": "Certificate renewer",
            "B": "Webhook server",
            "C": "Policy controller",
            "D": "Report controller"
        },
        "answer": "A"
    },
    {
        "question": "What is the default validationFailureAction for Kyverno policies?",
        "options": {
            "A": "Enforce",
            "B": "Audit",
            "C": "Warn",
            "D": "Ignore"
        },
        "answer": "B"
    },
    {
        "question": "What is the key difference between a Policy and a ClusterPolicy in Kyverno?",
        "options": {
            "A": "Policy applies to cluster-scoped resources, ClusterPolicy to namespaced",
            "B": "Policy is namespaced, ClusterPolicy is cluster-scoped",
            "C": "Policy supports only validation, ClusterPolicy supports all rule types",
            "D": "Policy requires RBAC, ClusterPolicy does not"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a generate rule specifies the namespace where the generated resource will be created?",
        "options": {
            "A": "namespace",
            "B": "generateNamespace",
            "C": "targetNamespace",
            "D": "resourceNamespace"
        },
        "answer": "C"
    },
    {
        "question": "What is the purpose of the `validationFailureAction` field set to 'Warn'?",
        "options": {
            "A": "Blocks the resource creation but logs a warning",
            "B": "Allows the resource but logs a warning",
            "C": "Prevents the resource and sends an alert",
            "D": "Ignores the policy violation completely"
        },
        "answer": "B"
    },
    {
        "question": "Which Kyverno CLI command runs policy tests defined in a test directory?",
        "options": {
            "A": "kyverno test ./tests",
            "B": "kyverno run-tests ./tests",
            "C": "kyverno validate-tests ./tests",
            "D": "kyverno execute-tests ./tests"
        },
        "answer": "A"
    },
    {
        "question": "How does Kyverno handle existing resources when a new policy with `background: true` is applied?",
        "options": {
            "A": "Ignores them unless manually triggered",
            "B": "Scans and evaluates them immediately",
            "C": "Waits for the resources to be updated",
            "D": "Only evaluates them during the next cluster restart"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL expression checks if a deployment has at least 3 replicas?",
        "options": {
            "A": "request.object.spec.replicas >= 3",
            "B": "object.spec.replicas > 3",
            "C": "request.spec.replicas >= 3",
            "D": "deployment.spec.replicas >= 3"
        },
        "answer": "A"
    },
    {
        "question": "What is the role of the `matchResources` field in a PolicyException?",
        "options": {
            "A": "Specifies policies to exclude",
            "B": "Defines resources exempt from the policy",
            "C": "Sets the scope of the exception",
            "D": "Configures exception duration"
        },
        "answer": "B"
    },
    {
        "question": "Which Helm value configures the maximum number of background workers in Kyverno?",
        "options": {
            "A": "background.workers",
            "B": "controller.maxWorkers",
            "C": "background.maxConcurrent",
            "D": "workerCount.background"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to use a wildcard in a policy's `match` block for all namespaces starting with 'dev-'?",
        "options": {
            "A": "namespaces: [\"dev-*\"]",
            "B": "namespaces: [\"dev-{{*}}\"]",
            "C": "namespaces: [\"regex:dev-.*\"]",
            "D": "namespaces: [\"glob:dev-*\"]"
        },
        "answer": "D"
    },
    {
        "question": "Which rule type can modify existing resources after they've been created?",
        "options": {
            "A": "Mutation (admission-time only)",
            "B": "Mutate-Existing",
            "C": "Generate (synchronized)",
            "D": "Validation (background)"
        },
        "answer": "B"
    },
    {
        "question": "What is the default interval for Kyverno's background scans?",
        "options": {
            "A": "1 minute",
            "B": "5 minutes",
            "C": "10 minutes",
            "D": "30 minutes"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a policy rule defines the error message shown when validation fails?",
        "options": {
            "A": "errorMessage",
            "B": "message",
            "C": "failureMessage",
            "D": "violationMessage"
        },
        "answer": "B"
    },
    {
        "question": "What permission is required for Kyverno to manage admission webhooks?",
        "options": {
            "A": "admissionregistration.k8s.io/webhooks",
            "B": "kyverno.io/policies",
            "C": "core/v1/configmaps",
            "D": "rbac.authorization.k8s.io/clusterroles"
        },
        "answer": "A"
    },
    {
        "question": "How do you reference a secret in a policy's context?",
        "options": {
            "A": "context: [{ secret: { name: 'my-secret' } }]",
            "B": "secrets: [{ name: 'my-secret' }]",
            "C": "variables: [{ secret: { name: 'my-secret' } }]",
            "D": "data: [{ secret: 'my-secret' }]"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI flag displays detailed policy evaluation logs?",
        "options": {
            "A": "--verbose",
            "B": "--debug",
            "C": "--logs",
            "D": "--details"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `policy.kubernetes.io/rule` label in PolicyReports?",
        "options": {
            "A": "Identifies the policy namespace",
            "B": "Specifies the rule that triggered the violation",
            "C": "Marks the severity of the violation",
            "D": "Indicates the resource kind"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL function converts a string to lowercase?",
        "options": {
            "A": "toLower(string)",
            "B": "string.toLowerCase()",
            "C": "lowercase(string)",
            "D": "string.lower()"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure a policy to apply only to resources created by a specific user?",
        "options": {
            "A": "match: { subjects: [{ kind: 'User', name: 'admin' }] }",
            "B": "match: { users: ['admin'] }",
            "C": "match: { request: { userInfo: { username: 'admin' } } }",
            "D": "match: { creator: 'admin' }"
        },
        "answer": "C"
    },
    {
        "question": "Which Kyverno component generates PolicyReports?",
        "options": {
            "A": "Report controller",
            "B": "Background controller",
            "C": "Webhook server",
            "D": "Policy controller"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of setting `enforce: false` in a validation rule?",
        "options": {
            "A": "Disables the rule entirely",
            "B": "Evaluates but doesn't block the resource",
            "C": "Applies only to existing resources",
            "D": "Overrides the global validationFailureAction"
        },
        "answer": "B"
    },
    {
        "question": "Which command exports Kyverno policy reports in JSON format?",
        "options": {
            "A": "kubectl get policyreport -o json",
            "B": "kyverno export reports --format json",
            "C": "kubectl describe policyreport -o json",
            "D": "kyverno report export -f json"
        },
        "answer": "A"
    },
    {
        "question": "What is the correct structure for a mutation rule that adds an annotation to all pods?",
        "options": {
            "A": "mutate: { annotations: { 'security': 'enabled' } }",
            "B": "mutate: { patchStrategicMerge: { metadata: { annotations: { 'security': 'enabled' } } } }",
            "C": "mutation: { add: { annotations: { 'security': 'enabled' } } }",
            "D": "patch: { op: 'add', path: '/metadata/annotations/security', value: 'enabled' }"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a generate rule determines if the generated resource is owned by the source resource?",
        "options": {
            "A": "owned",
            "B": "ownerReference",
            "C": "synchronize",
            "D": "manage"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `kyverno-policies` namespace?",
        "options": {
            "A": "Stores default Kyverno policies",
            "B": "Runs Kyverno controller pods",
            "C": "Holds policy reports",
            "D": "Contains webhook configurations"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression checks if a container's image is from a trusted registry 'myregistry.com'?",
        "options": {
            "A": "request.object.spec.containers[0].image.contains('myregistry.com')",
            "B": "contains(request.object.spec.containers[0].image, 'myregistry.com')",
            "C": "request.object.spec.containers[0].image.startsWith('myregistry.com/')",
            "D": "startsWith(request.object.spec.containers[0].image, 'myregistry.com')"
        },
        "answer": "C"
    },
    {
        "question": "How do you set a policy to take precedence over other policies?",
        "options": {
            "A": "priority: high",
            "B": "spec.priority: 100",
            "C": "precedence: 10",
            "D": "order: first"
        },
        "answer": "B"
    },
    {
        "question": "Which flag in `kyverno apply` specifies a policy file?",
        "options": {
            "A": "-f",
            "B": "--policy",
            "C": "-p",
            "D": "--file"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `validationFailureAction: Enforce` in a policy?",
        "options": {
            "A": "Logs violations but allows resources",
            "B": "Blocks resources that violate the policy",
            "C": "Auto-corrects violations",
            "D": "Sends alerts to a monitoring system"
        },
        "answer": "B"
    },
    {
        "question": "Which Kyverno feature allows policies to share common variables?",
        "options": {
            "A": "Policy libraries",
            "B": "Context variables",
            "C": "Shared configmaps",
            "D": "Policy templates"
        },
        "answer": "B"
    },
    {
        "question": "What is the correct way to exclude a specific pod named 'special-pod' from a policy?",
        "options": {
            "A": "exclude: { any: [{ resources: { names: ['special-pod'], kinds: ['Pod'] } }] }",
            "B": "exclude: { resources: { name: 'special-pod', kind: 'Pod' } }",
            "C": "exclude: { names: ['special-pod'], kinds: ['Pod'] }",
            "D": "exclude: { all: [{ name: 'special-pod' }, { kind: 'Pod' }] }"
        },
        "answer": "A"
    },
    {
        "question": "Which Kubernetes resource scope can only be targeted by a ClusterPolicy?",
        "options": {
            "A": "Namespaced resources in a specific namespace",
            "B": "Cluster-scoped resources like Namespace or Node",
            "C": "Pod resources in the default namespace",
            "D": "ConfigMaps and Secrets"
        },
        "answer": "B"
    },
    {
        "question": "How do you create a mutation rule that applies to all containers in a pod (not just the first one)?",
        "options": {
            "A": "Use `containers: *` in the patch path",
            "B": "Use a loop with `foreach` in the mutation block",
            "C": "Specify `allContainers: true` in the mutate section",
            "D": "Apply the patch to `spec.containers[]` without an index"
        },
        "answer": "D"
    },
    {
        "question": "Which CEL expression checks if a pod has at least 2 containers?",
        "options": {
            "A": "request.object.spec.containers.size() >= 2",
            "B": "len(request.object.spec.containers) >= 2",
            "C": "request.object.spec.containers.count() >= 2",
            "D": "request.object.spec.containers.length >= 2"
        },
        "answer": "A"
    },
    {
        "question": "What field in a PolicyException specifies individual rules to exclude from a policy?",
        "options": {
            "A": "rules",
            "B": "excludedRules",
            "C": "ruleExceptions",
            "D": "skipRules"
        },
        "answer": "A"
    },
    {
        "question": "Which operation requires Kyverno to have read access to the Kubernetes API server?",
        "options": {
            "A": "Applying admission-time mutations",
            "B": "Generating resources based on existing ones",
            "C": "Logging policy violations",
            "D": "Validating resource creation"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of setting `owned: true` in a generate rule?",
        "options": {
            "A": "The generated resource is deleted when the source resource is deleted",
            "B": "Kyverno becomes the owner of the source resource",
            "C": "The generated resource cannot be modified manually",
            "D": "The source resource inherits labels from the generated resource"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command validates a policy's syntax without applying it?",
        "options": {
            "A": "kyverno validate policy.yaml",
            "B": "kyverno check policy.yaml",
            "C": "kyverno lint policy.yaml",
            "D": "kyverno verify policy.yaml"
        },
        "answer": "C"
    },
    {
        "question": "How do you configure Kyverno to skip policy evaluation for kube-system resources by default?",
        "options": {
            "A": "Set `excludeNamespaces: [kube-system]` in the Kyverno config",
            "B": "Create a global PolicyException for kube-system",
            "C": "Use `--skip-system` during Kyverno installation",
            "D": "Add `system: true` to the namespace metadata"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression checks if a pod's image tag is not 'latest'?",
        "options": {
            "A": "request.object.spec.containers[0].image.split(':')[1] != 'latest'",
            "B": "request.object.spec.containers[0].image.contains(':') && request.object.spec.containers[0].image.split(':')[1] != 'latest'",
            "C": "!request.object.spec.containers[0].image.endsWith(':latest')",
            "D": "request.object.spec.containers[0].image.tag != 'latest'"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `kyverno-config` ConfigMap?",
        "options": {
            "A": "Stores default policy templates",
            "B": "Configures global Kyverno settings like excluded namespaces",
            "C": "Stores policy report data",
            "D": "Defines webhook timeouts"
        },
        "answer": "B"
    },
    {
        "question": "Which rule type can both create new resources and update existing ones?",
        "options": {
            "A": "Generate with `synchronize: true`",
            "B": "Mutate-Existing",
            "C": "Validation with `background: true`",
            "D": "ClusterGenerate"
        },
        "answer": "A"
    },
    {
        "question": "How do you reference a label from the source resource in a generate rule's template?",
        "options": {
            "A": "{{ source.labels.app }}",
            "B": "{{ request.object.metadata.labels.app }}",
            "C": "{{ generate.source.labels.app }}",
            "D": "{{ labels.app from source }}"
        },
        "answer": "B"
    },
    {
        "question": "Which Kyverno metric counts the number of policy violations?",
        "options": {
            "A": "kyverno_policy_violations_total",
            "B": "policy_validation_failures",
            "C": "kyverno_violations_count",
            "D": "policy_evaluation_errors"
        },
        "answer": "A"
    },
    {
        "question": "What is the correct way to use a regex in a `match` block to target resources with names containing 'app-' followed by numbers?",
        "options": {
            "A": "names: [\"regex:app-\\d+\"]",
            "B": "names: [\"app-[0-9]+\"]",
            "C": "names: [\"glob:app-*[0-9]\"]",
            "D": "names: [\"regex:app-[0-9]+\"]"
        },
        "answer": "D"
    },
    {
        "question": "Which field controls the timeout for Kyverno webhook requests?",
        "options": {
            "A": "webhookTimeoutSeconds",
            "B": "requestTimeout",
            "C": "webhookRequestTimeout",
            "D": "timeoutSeconds"
        },
        "answer": "A"
    },
    {
        "question": "What is required to use a custom CEL function in Kyverno policies?",
        "options": {
            "A": "Enabling the `customCEL` feature gate",
            "B": "Kyverno does not support custom CEL functions",
            "C": "Installing the CEL extension plugin",
            "D": "Defining functions in the `kyverno-config` ConfigMap"
        },
        "answer": "B"
    },
    {
        "question": "How do you test a policy that is expected to fail a resource?",
        "options": {
            "A": "Set `expected: failure` in the test case",
            "B": "Use `kyverno test --expect-failure`",
            "C": "Mark the resource as `invalid: true` in the test file",
            "D": "No special configuration is needed; failures are automatically detected"
        },
        "answer": "A"
    },
    {
        "question": "Which Kubernetes RBAC role is required for Kyverno to generate Secrets?",
        "options": {
            "A": "secret-editor",
            "B": "kyverno:generate:secrets",
            "C": "cluster-admin",
            "D": "A role with `create` and `update` permissions on Secrets"
        },
        "answer": "D"
    },
    {
        "question": "What is the effect of `mutationFailureAction: Block` in a policy?",
        "options": {
            "A": "Allows the resource if mutation fails",
            "B": "Blocks the resource if mutation cannot be applied",
            "C": "Logs an error but applies the resource without mutation",
            "D": "Triggers a retry of the mutation"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL expression checks if a namespace has both 'env=prod' and 'team=backend' labels?",
        "options": {
            "A": "request.object.metadata.labels.env == 'prod' && request.object.metadata.labels.team == 'backend'",
            "B": "request.object.labels.env == 'prod' AND request.object.labels.team == 'backend'",
            "C": "all(request.object.metadata.labels, [env: 'prod', team: 'backend'])",
            "D": "request.object.metadata.labels contains {env: 'prod', team: 'backend'}"
        },
        "answer": "A"
    },
    {
        "question": "How do you configure a generate rule to create a resource only if it doesn't already exist?",
        "options": {
            "A": "Set `createIfNotExists: true`",
            "B": "Omit the `synchronize` field (default behavior)",
            "C": "Set `onExisting: Ignore`",
            "D": "Use `generateOnlyOnce: true`"
        },
        "answer": "B"
    },
    {
        "question": "Which command lists all ClusterPolicies in the cluster?",
        "options": {
            "A": "kubectl get clusterpolicies",
            "B": "kyverno list clusterpolicies",
            "C": "kubectl get cp",
            "D": "kyverno get cluster-policies"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `preconditions` field in a policy rule?",
        "options": {
            "A": "Define conditions that must be met for the rule to execute",
            "B": "Set the order of rule execution",
            "C": "Specify resources to exclude from the rule",
            "D": "Configure retries for failed evaluations"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno component is responsible for updating PolicyReports with background scan results?",
        "options": {
            "A": "Background controller",
            "B": "Report controller",
            "C": "Policy controller",
            "D": "Scan controller"
        },
        "answer": "B"
    },
    {
        "question": "How do you reference a value from an external API call in a policy rule?",
        "options": {
            "A": "{{ apiCall.response.value }}",
            "B": "{{ context.apiCall.data.value }}",
            "C": "{{ external.api.value }}",
            "D": "{{ api.response.value }}"
        },
        "answer": "B"
    },
    {
        "question": "What is the default maximum number of policy rules allowed in a single ClusterPolicy?",
        "options": {
            "A": "10",
            "B": "20",
            "C": "50",
            "D": "Unlimited"
        },
        "answer": "C"
    },
    {
        "question": "Which field in a policy specifies the Kubernetes API versions it targets?",
        "options": {
            "A": "apiVersions",
            "B": "targetAPIVersions",
            "C": "kubernetesVersions",
            "D": "apiGroups"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `dryRun: true` in a `kyverno apply` command?",
        "options": {
            "A": "Evaluates policies without modifying resources or creating reports",
            "B": "Applies policies but rolls back changes after 30 seconds",
            "C": "Runs policies in audit mode temporarily",
            "D": "Generates a preview of policy changes without applying them"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL function checks if a list of annotations contains any entry with a key starting with 'security.'?",
        "options": {
            "A": "request.object.metadata.annotations.any(key, key.startsWith('security.'))",
            "B": "any(request.object.metadata.annotations.keys(), k, k.startsWith('security.'))",
            "C": "request.object.metadata.annotations.hasKeyStartingWith('security.')",
            "D": "startsWithAny(request.object.metadata.annotations.keys(), 'security.')"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure Kyverno to use a custom CA certificate for external API calls?",
        "options": {
            "A": "Add the CA to the `kyverno-sa` service account's secret",
            "B": "Set `caBundle` in the API call context configuration",
            "C": "Mount the CA certificate in the Kyverno pod's `/etc/ssl/certs` directory",
            "D": "Configure `customCA: true` in the Kyverno Helm values"
        },
        "answer": "B"
    },
    {
        "question": "How do you create a time-limited PolicyException that expires after 7 days?",
        "options": {
            "A": "Add `expires: 7d` in the exception spec",
            "B": "Set `ttl: 168h` in the exception metadata",
            "C": "Include `duration: 7` in the exception spec with `unit: days`",
            "D": "PolicyExceptions cannot be time-limited"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression converts a CPU limit string '500m' to its millicore numeric value?",
        "options": {
            "A": "parseInt(request.object.spec.containers[0].resources.limits.cpu.replace('m', ''))",
            "B": "request.object.spec.containers[0].resources.limits.cpu.toMillicores()",
            "C": "cpu(request.object.spec.containers[0].resources.limits.cpu)",
            "D": "request.object.spec.containers[0].resources.limits.cpu.numericValue()"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `failurePolicy` in a ValidatingWebhookConfiguration used by Kyverno?",
        "options": {
            "A": "Defines how to handle policy evaluation errors",
            "B": "Specifies whether to allow or block resources when the webhook is unavailable",
            "C": "Configures retry logic for failed webhook calls",
            "D": "Sets the severity level for policy violations"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a generate rule allows you to use a template from a ConfigMap?",
        "options": {
            "A": "templateFrom: { configMap: { name: 'my-templates', key: 'pod-template' } }",
            "B": "configMapTemplate: 'my-templates/pod-template'",
            "C": "templateSource: { configMap: 'my-templates', entry: 'pod-template' }",
            "D": "useTemplate: 'configmap://my-templates/pod-template'"
        },
        "answer": "A"
    },
    {
        "question": "How do you exclude resources with a label selector `env in (dev, test)` from a policy?",
        "options": {
            "A": "exclude: { any: [{ resources: { selector: { matchExpressions: [{ key: 'env', operator: 'In', values: ['dev', 'test'] }] } }] }",
            "B": "exclude: { labels: { env: ['dev', 'test'] } }",
            "C": "exclude: { resources: { labelSelector: 'env in (dev,test)' } }",
            "D": "exclude: { selectors: [{ env: ['dev', 'test'] }] }"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno CLI command exports policy metrics in Prometheus format?",
        "options": {
            "A": "kyverno metrics export",
            "B": "kyverno get metrics --format prometheus",
            "C": "kyverno metrics --prometheus",
            "D": "Kyverno CLI does not export metrics; metrics are exposed by the controller"
        },
        "answer": "D"
    },
    {
        "question": "What is the effect of `validationFailureAction: Audit` on a policy with `background: false`?",
        "options": {
            "A": "Evaluates only new resources and logs violations",
            "B": "Evaluates existing resources and blocks non-compliant ones",
            "C": "Ignores existing resources but audits new ones",
            "D": "Audits all resources (existing and new) continuously"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression checks if any container in a pod has a memory limit defined?",
        "options": {
            "A": "request.object.spec.containers.any(c, c.resources.limits.memory.exists())",
            "B": "any(request.object.spec.containers, c, c.resources.limits.memory != null)",
            "C": "request.object.spec.containers.all(c, c.resources.limits.memory exists)",
            "D": "request.object.spec.containers.some(c => c.resources.limits.memory)"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure Kyverno to use a custom webhook port instead of the default 9443?",
        "options": {
            "A": "Set `webhook.port` in the Kyverno Helm values",
            "B": "Modify the `kyverno-config` ConfigMap's `webhookPort` key",
            "C": "Use `--webhook-port=8443` in the Kyverno deployment command",
            "D": "Kyverno webhook port is fixed and cannot be changed"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `severity` field in a policy rule?",
        "options": {
            "A": "Determines the order of policy execution",
            "B": "Sets the priority level for policy evaluation",
            "C": "Classifies violations in PolicyReports (e.g., Low, High)",
            "D": "Defines the timeout for rule evaluation"
        },
        "answer": "C"
    },
    {
        "question": "Which rule type can both validate and mutate resources in a single rule?",
        "options": {
            "A": "CombinedRule",
            "B": "ValidateMutate",
            "C": "Kyverno rules can only perform one action per rule",
            "D": "MultiActionRule"
        },
        "answer": "C"
    },
    {
        "question": "How do you reference a field from another namespace's ConfigMap in a policy?",
        "options": {
            "A": "context: [{ configMap: { name: 'my-config', namespace: 'shared' } }]",
            "B": "context: [{ configMap: 'shared/my-config' }]",
            "C": "variables: [{ configMap: { name: 'my-config', fromNamespace: 'shared' } }]",
            "D": "Kyverno can only reference ConfigMaps in the same namespace as the policy"
        },
        "answer": "A"
    },
    {
        "question": "Which command describes the details of a specific ClusterPolicy, including its rules?",
        "options": {
            "A": "kubectl describe clusterpolicy my-policy",
            "B": "kyverno explain clusterpolicy my-policy",
            "C": "kubectl get clusterpolicy my-policy -o yaml",
            "D": "kyverno describe policy my-policy --cluster"
        },
        "answer": "A"
    },
    {
        "question": "What is the default cache duration for Kyverno policy evaluations?",
        "options": {
            "A": "1 minute",
            "B": "5 minutes",
            "C": "10 minutes",
            "D": "30 minutes"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL expression checks if a pod's service account is not 'default'?",
        "options": {
            "A": "request.object.spec.serviceAccountName != 'default'",
            "B": "request.object.spec.serviceAccount != 'default'",
            "C": "request.object.serviceAccountName != 'default'",
            "D": "object.spec.serviceAccountName != 'default'"
        },
        "answer": "A"
    },
    {
        "question": "How do you configure a generate rule to create a resource in the same namespace as the source resource?",
        "options": {
            "A": "Set `targetNamespace: {{request.object.metadata.namespace}}`",
            "B": "Omit `targetNamespace` (default behavior)",
            "C": "Set `targetNamespace: same`",
            "D": "Use `namespace: {{source.namespace}}`"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno component is responsible for caching policy evaluations to improve performance?",
        "options": {
            "A": "Cache controller",
            "B": "Evaluation controller",
            "C": "Webhook server",
            "D": "Policy controller"
        },
        "answer": "C"
    },
    {
        "question": "What is the effect of `ignoreExisting: true` in a mutate-existing rule?",
        "options": {
            "A": "Applies the mutation only to new resources, not existing ones",
            "B": "Skips mutation for resources that already exist when the policy is applied",
            "C": "Ignores existing mutations on resources",
            "D": "Overwrites all existing fields with the mutation"
        },
        "answer": "B"
    },
    {
        "question": "How do you set a custom message for a PolicyException in reports?",
        "options": {
            "A": "Add `message: 'Temporary exception for maintenance'` in the exception spec",
            "B": "Set `exceptionMessage` in the exception metadata",
            "C": "PolicyExceptions cannot have custom messages",
            "D": "Use `note: 'Maintenance window'` in the exception spec"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression checks if a deployment's image is using a SHA digest (not a tag)?",
        "options": {
            "A": "request.object.spec.template.spec.containers[0].image.contains('@sha256:')",
            "B": "request.object.spec.template.spec.containers[0].image matches '.*@sha256:.*'",
            "C": "isDigest(request.object.spec.template.spec.containers[0].image)",
            "D": "request.object.spec.template.spec.containers[0].image.endsWith('sha256')"
        },
        "answer": "A"
    },
    {
        "question": "What permission is required for Kyverno to update existing resources with mutate-existing rules?",
        "options": {
            "A": "\"update\" on the target resource kind",
            "B": "\"patch\" on the target resource kind",
            "C": "\"edit\" cluster role",
            "D": "\"mutate\" verb on the target resource kind"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure a policy to apply only during working hours (9am-5pm UTC)?",
        "options": {
            "A": "Use `schedule: '9-17 * * 1-5'` in the policy spec",
            "B": "Kyverno does not support time-based policy scheduling",
            "C": "Add a CEL condition checking the current time",
            "D": "Set `activeHours: '09:00-17:00'` in the policy spec"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a PolicyReport indicates the time of the last policy evaluation?",
        "options": {
            "A": "lastEvaluated",
            "B": "timestamp",
            "C": "lastUpdateTime",
            "D": "evaluationTime"
        },
        "answer": "C"
    },
    {
        "question": "What is the correct way to use a label from a namespace in a pod-focused policy?",
        "options": {
            "A": "context: [{ name: 'ns', apiCall: { url: '/api/v1/namespaces/{{request.object.metadata.namespace}}' } }]",
            "B": "variables: [{ namespaceLabel: { key: 'env', fromNamespace: '{{request.namespace}}' } }]",
            "C": "reference: { namespace: '{{request.namespace}}', field: 'metadata.labels.env' }",
            "D": "Kyverno cannot reference namespace labels in pod policies"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command displays the history of policy violations for a specific resource?",
        "options": {
            "A": "kyverno violations history pod/my-pod",
            "B": "kubectl describe policyreport -l policy.kubernetes.io/resource=my-pod",
            "C": "kyverno history pod/my-pod",
            "D": "kubectl get policyreport -o jsonpath='{.results[?(@.resource.name==\"my-pod\")]}'"
        },
        "answer": "D"
    },
    {
        "question": "What is the purpose of the `policy.kubernetes.io/skip` annotation?",
        "options": {
            "A": "Excludes a specific resource from all Kyverno policies",
            "B": "Skips a single policy evaluation for a resource",
            "C": "Disables mutation rules for a resource",
            "D": "Marks a resource as compliant without evaluation"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression calculates the ratio of CPU limit to request for a container?",
        "options": {
            "A": "parseInt(request.object.spec.containers[0].resources.limits.cpu.replace('m', '')) / parseInt(request.object.spec.containers[0].resources.requests.cpu.replace('m', ''))",
            "B": "request.object.spec.containers[0].resources.limits.cpu / request.object.spec.containers[0].resources.requests.cpu",
            "C": "cpuLimit(request.object) / cpuRequest(request.object)",
            "D": "toNumber(request.object.spec.containers[0].resources.limits.cpu) / toNumber(request.object.spec.containers[0].resources.requests.cpu)"
        },
        "answer": "A"
    },
    {
        "question": "How do you configure Kyverno to log all policy evaluations to a file?",
        "options": {
            "A": "Set `logFile: /var/log/kyverno/evaluations.log` in the Kyverno config",
            "B": "Add `--log-to-file` to the Kyverno deployment command",
            "C": "Kyverno logs to stdout/stderr by default; use a sidecar to write to a file",
            "D": "Configure `logging.file: true` in the Helm values"
        },
        "answer": "C"
    },
    {
        "question": "What is the effect of `synchronize: false` in a generate rule?",
        "options": {
            "A": "The generated resource is created once and not updated if the policy changes",
            "B": "The generated resource is deleted when the policy is updated",
            "C": "Kyverno stops monitoring the source resource for changes",
            "D": "The generated resource is only created if the source resource is updated"
        },
        "answer": "A"
    },
    {
        "question": "Which field in a policy specifies the minimum Kyverno version required to enforce it?",
        "options": {
            "A": "minVersion",
            "B": "kyvernoVersion",
            "C": "requiredVersion",
            "D": "minimumKyvernoVersion"
        },
        "answer": "A"
    },
    {
        "question": "Which type of policy report is generated for cluster-scoped resources like Node or Namespace?",
        "options": {
            "A": "NamespacePolicyReport",
            "B": "ClusterPolicyReport",
            "C": "GlobalPolicyReport",
            "D": "AggregatedPolicyReport"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure Kyverno to perform background scans every 30 minutes?",
        "options": {
            "A": "Set `backgroundScanInterval: 30m` in the kyverno-config ConfigMap",
            "B": "Use `--background-scan-interval=1800` when deploying Kyverno",
            "C": "Add `schedule: '*/30 * * * *'` to the policy spec",
            "D": "Modify the `kyverno` Deployment's `BACKGROUND_SCAN_INTERVAL` environment variable"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL expression checks if a pod was created in the last 24 hours?",
        "options": {
            "A": "request.object.metadata.creationTimestamp.seconds > (now().seconds - 86400)",
            "B": "request.object.metadata.creationTimestamp.seconds < (now().seconds - 86400)",
            "C": "request.object.metadata.creationTimestamp.seconds >= (now().seconds - 86400)",
            "D": "request.object.metadata.creationTimestamp.seconds <= (now().seconds - 86400)"
        },
        "answer": "A"
    },
    {
        "question": "What is the valid range for the `webhookTimeoutSeconds` field in a policy?",
        "options": {
            "A": "1-10 seconds",
            "B": "1-30 seconds",
            "C": "5-60 seconds",
            "D": "Unlimited"
        },
        "answer": "B"
    },
    {
        "question": "During resource admission, which type of rule executes first?",
        "options": {
            "A": "Validation rules",
            "B": "Mutation rules",
            "C": "Generate rules",
            "D": "Image verification rules"
        },
        "answer": "B"
    },
    {
        "question": "How do you verify a container image's Cosign signature in a Kyverno policy?",
        "options": {
            "A": "Use `verifyImages` with `type: cosign` and specify the public key",
            "B": "Add `cosign: true` to the policy's `validate` section",
            "C": "Include `cosignPublicKey: '-----BEGIN PUBLIC KEY-----...'` in the policy metadata",
            "D": "Set `imageSignature: required` in the container spec"
        },
        "answer": "A"
    },
    {
        "question": "What is required to create a policy targeting a Custom Resource Definition (CRD)?",
        "options": {
            "A": "Define `apiGroups` and `kinds` in the policy's `match` section",
            "B": "Install the CRD in the kyverno namespace",
            "C": "Enable the `CRDValidation` feature gate",
            "D": "Use `ClusterPolicy` instead of `Policy`"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno metric tracks the number of policy violations?",
        "options": {
            "A": "kyverno_policy_violations_total",
            "B": "policy_validation_failures",
            "C": "kyverno_violations_count",
            "D": "policy_evaluation_errors"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `failurePolicy` field in a ValidatingWebhookConfiguration?",
        "options": {
            "A": "Define retry logic for failed webhook calls",
            "B": "Specify whether to allow resources if the webhook fails",
            "C": "Configure the severity level of policy violations",
            "D": "Set the timeout for webhook requests"
        },
        "answer": "B"
    },
    {
        "question": "How do you reference a ConfigMap from another namespace in a policy's context?",
        "options": {
            "A": "Use `context: [{ configMap: { name: 'my-config', namespace: 'other-ns' } }]`",
            "B": "Set `namespace: 'other-ns'` in the policy metadata",
            "C": "Add `crossNamespace: true` to the policy's `match` section",
            "D": "Kyverno cannot reference ConfigMaps from other namespaces"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command generates a policy report for all resources in a namespace?",
        "options": {
            "A": "kyverno report namespace my-ns",
            "B": "kubectl get policyreport -n my-ns",
            "C": "kyverno generate report my-ns",
            "D": "kubectl describe policyreport -n my-ns"
        },
        "answer": "B"
    },
    {
        "question": "What is the effect of `mutationFailureAction: Ignore` in a policy?",
        "options": {
            "A": "Blocks the resource if mutation fails",
            "B": "Applies the resource without mutation on failure",
            "C": "Retries the mutation up to 3 times",
            "D": "Generates an error but allows the resource"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL function checks if a string ends with a specific suffix?",
        "options": {
            "A": "endsWith(request.object.metadata.name, '-prod')",
            "B": "request.object.metadata.name.endsWith('-prod')",
            "C": "hasSuffix(request.object.metadata.name, '-prod')",
            "D": "string.endsWith(request.object.metadata.name, '-prod')"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure Kyverno to use a custom Prometheus metrics port?",
        "options": {
            "A": "Set `metrics.port` in the Helm values",
            "B": "Modify the `kyverno-svc` Service's port definition",
            "C": "Use `--metrics-port=9090` during deployment",
            "D": "Kyverno metrics port is fixed at 8000"
        },
        "answer": "A"
    },
    {
        "question": "What permission is required for Kyverno to update existing resources with `mutate-existing` rules?",
        "options": {
            "A": "update",
            "B": "patch",
            "C": "edit",
            "D": "mutate"
        },
        "answer": "B"
    },
    {
        "question": "Which field in a policy specifies the minimum Kyverno version required?",
        "options": {
            "A": "minVersion",
            "B": "kyvernoVersion",
            "C": "requiredVersion",
            "D": "minimumKyvernoVersion"
        },
        "answer": "A"
    },
    {
        "question": "How do you test a policy that is expected to fail a resource?",
        "options": {
            "A": "Set `expected: failure` in the test case",
            "B": "Use `kyverno test --expect-failure`",
            "C": "Mark the resource as `invalid: true` in the test file",
            "D": "No special configuration needed; failures are detected automatically"
        },
        "answer": "A"
    },
    {
        "question": "What is the purpose of the `severity` field in a policy rule?",
        "options": {
            "A": "Determine the order of policy execution",
            "B": "Classify violations in PolicyReports",
            "C": "Set the timeout for rule evaluation",
            "D": "Define the RBAC permissions required"
        },
        "answer": "B"
    },
    {
        "question": "Which CEL expression checks if a pod has both 'app' and 'env' labels?",
        "options": {
            "A": "request.object.metadata.labels.app.exists() && request.object.metadata.labels.env.exists()",
            "B": "request.object.metadata.labels.contains('app') AND request.object.metadata.labels.contains('env')",
            "C": "all(request.object.metadata.labels, [app, env])",
            "D": "request.object.metadata.labels.app != null || request.object.metadata.labels.env != null"
        },
        "answer": "A"
    },
    {
        "question": "How do you exclude a specific resource from all Kyverno policies?",
        "options": {
            "A": "Add the `policy.kubernetes.io/skip` annotation",
            "B": "Create a PolicyException for the resource",
            "C": "Use `exclude` in the policy's `match` section",
            "D": "Delete the resource from the cluster"
        },
        "answer": "A"
    },
    {
        "question": "Which command lists all ClusterPolicies in the cluster?",
        "options": {
            "A": "kubectl get clusterpolicies",
            "B": "kyverno list clusterpolicies",
            "C": "kubectl get cp",
            "D": "kyverno get cluster-policies"
        },
        "answer": "A"
    },
    {
        "question": "What is the effect of `dryRun: true` in a `kyverno apply` command?",
        "options": {
            "A": "Evaluates policies without modifying resources",
            "B": "Applies policies but rolls back changes after 30 seconds",
            "C": "Runs policies in audit mode temporarily",
            "D": "Generates a preview of policy changes"
        },
        "answer": "A"
    },
    {
        "question": "Which Kyverno component handles background scans and policy report aggregation?",
        "options": {
            "A": "Background controller",
            "B": "Report controller",
            "C": "Policy controller",
            "D": "Webhook server"
        },
        "answer": "B"
    },
    {
        "question": "How do you configure a generate rule to create a resource in a specific namespace?",
        "options": {
            "A": "Set `targetNamespace: 'my-ns'` in the generate rule",
            "B": "Omit `targetNamespace` (default to source namespace)",
            "C": "Use `namespace: 'my-ns'` in the resource template",
            "D": "Add `namespaceSelector: { matchLabels: { env: 'prod' } }`"
        },
        "answer": "A"
    },
    {
        "question": "Which field in a PolicyException specifies the policy to exclude?",
        "options": {
            "A": "policy",
            "B": "excludedPolicy",
            "C": "policyName",
            "D": "skipPolicy"
        },
        "answer": "A"
    },
    {
        "question": "What is the correct way to use a regex in a `match` block to target resources with names starting with 'app-'?",
        "options": {
            "A": "names: [\"regex:app-.*\"]",
            "B": "names: [\"glob:app-*\"]",
            "C": "names: [\"app-*\"]",
            "D": "names: [\"regex:^app-.*$\"]"
        },
        "answer": "A"
    },
    {
        "question": "Which CLI command validates a policy's syntax without applying it?",
        "options": {
            "A": "kyverno validate policy.yaml",
            "B": "kyverno check policy.yaml",
            "C": "kyverno lint policy.yaml",
            "D": "kyverno verify policy.yaml"
        },
        "answer": "C"
    },
    {
        "question": "How do you configure Kyverno to skip policy evaluation for kube-system resources by default?",
        "options": {
            "A": "Set `excludeNamespaces: [kube-system]` in the kyverno-config ConfigMap",
            "B": "Create a global PolicyException for kube-system",
            "C": "Use `--skip-system` during Kyverno installation",
            "D": "Add `system: true` to the namespace metadata"
        },
        "answer": "A"
    },
    {
        "question": "Which CEL expression checks if a container's memory limit is at least 1Gi?",
        "options": {
            "A": "request.object.spec.containers[0].resources.limits.memory >= '1Gi'",
            "B": "request.object.spec.containers[0].resources.limits.memory.numericValue() >= 1073741824",
            "C": "request.object.spec.containers[0].resources.limits.memory.toBytes() >= 1073741824",
            "D": "request.object.spec.containers[0].resources.limits.memory.matches('^1Gi$')"
        },
        "answer": "B"
    },
    {
        "question": "What is the purpose of the `owned: true` field in a generate rule?",
        "options": {
            "A": "The generated resource is deleted when the source resource is deleted",
            "B": "Kyverno becomes the owner of the source resource",
            "C": "The generated resource cannot be modified manually",
            "D": "The source resource inherits labels from the generated resource"
        },
        "answer": "A"
    }
]
